name: Deploy to Raspberry Pi (Docker)

on:
  push:
    branches:
      - main # main 브랜치에 푸시될 때 실행

jobs:
  deploy:
    runs-on: ubuntu-latest # GitHub Actions 실행 환경

    steps:
      - name: Deploy to Raspberry Pi via SSH
        # SSH 접속 및 배포 스크립트 실행
        run: |
          sshpass -p "${{ secrets.RPI_PASSWORD }}" ssh -o StrictHostKeyChecking=no -p ${{ secrets.RPI_PORT }} ${{ secrets.RPI_USER }}@${{ secrets.RPI_HOST }} << 'EOF'
            # === 스크립트 시작 ===
            set -e # 오류 발생 시 즉시 중지
            # 1. 프로젝트 디렉터리로 이동
            echo "Navigating to project directory..."
            cd /home/${{ secrets.RPI_USER }}/MOUP-Server
            # 2. 최신 코드 받기 (SSH 키 설정 포함)
            echo "Pulling latest code from Git..."
            # (선택) SSH 에이전트 시작 및 키 추가 (Private Repo인 경우 필요)
            eval "$(ssh-agent -s)"
            echo "${{ secrets.RPI_DEPLOY_KEY }}" | ssh-add -
            git pull origin main
            ssh-agent -k # 에이전트 종료
            # 3. .env 파일 생성 (Secrets -> .env)
            echo "Creating .env file..."
            # [중요] Docker 내부 통신용 주소로 설정
            echo "DATABASE_URL=jdbc:mysql://mysql:3306/${{ secrets.DATABASE_NAME }}?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=Asia/Seoul" > .env
            echo "DATABASE_USERNAME=${{ secrets.DATABASE_USERNAME }}" >> .env
            echo "DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}" >> .env
            echo "DATABASE_NAME=${{ secrets.DATABASE_NAME }}" >> .env
            echo "REDIS_HOST=${{ secrets.REDIS_HOST }}" >> .env
            echo "REDIS_PORT=${{ secrets.REDIS_PORT }}" >> .env
            echo "REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}" >> .env
            echo "JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY }}" >> .env
            echo "KEYSTORE_PASSWORD=${{ secrets.KEYSTORE_PASSWORD }}" >> .env # Nginx에서 SSL 처리하므로 이 변수는 Spring에서 필요 없을 수 있음
            echo "S3_BUCKET_NAME=${{ secrets.S3_BUCKET_NAME }}" >> .env
            echo "AWS_ACCESS_KEY=${{ secrets.AWS_ACCESS_KEY }}" >> .env
            echo "AWS_SECRET_KEY=${{ secrets.AWS_SECRET_KEY }}" >> .env
            echo "GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}" >> .env
            echo "GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}" >> .env
            echo "GOOGLE_REDIRECT_URI=${{ secrets.GOOGLE_REDIRECT_URI }}" >> .env
            echo "APPLE_CLIENT_ID=${{ secrets.APPLE_CLIENT_ID }}" >> .env
            echo "APPLE_TEAM_ID=${{ secrets.APPLE_TEAM_ID }}" >> .env
            echo "APPLE_KEY_ID=${{ secrets.APPLE_KEY_ID }}" >> .env
            echo "APPLE_PRIVATE_KEY=${{ secrets.APPLE_PRIVATE_KEY }}" >> .env
            echo "APPLE_REDIRECT_URI=${{ secrets.APPLE_REDIRECT_URI }}" >> .env
            echo "ADMIN_AUTH_TOKEN=${{ secrets.ADMIN_AUTH_TOKEN }}" >> .env
            echo "FIREBASE_ACCOUNT_KEY_PATH=${{ secrets.FIREBASE_ACCOUNT_KEY_PATH }}" >> .env # Spring에서 classpath: 경로 사용하는지 확인
            # 4. Docker Compose로 빌드 및 배포
            echo "Starting Docker Compose deployment..."
            # (선택) 베이스 이미지 최신화 (배포 시간 단축 원하면 주석 처리)
            # docker compose pull mysql redis nginx
            # 이미지 빌드 (변경 사항 있을 시) 및 컨테이너 재시작/생성
            # --build: Dockerfile 또는 context 변경 시 server 이미지 리빌드
            # up -d: 변경된 컨테이너만 업데이트하고 백그라운드 실행
            docker compose up -d --build
            echo "Deployment complete."
            # 5. (선택) 불필요한 Docker 이미지 정리 (용량 확보)
            echo "Pruning unused Docker images..."
            docker image prune -af
            # 6. Crontab 설정 (사용자 삭제 스크립트)
            # echo "Setting up crontab..."
            # DELETE_SCRIPT="/home/${{ secrets.RPI_USER }}/MOUP-Server/src/main/resources/delete_old_users.sh"
            # chmod +x "$DELETE_SCRIPT" # 실행 권한 부여
            # # 기존 스케줄 삭제 후 새로 등록 (멱등성 확보)
            # (crontab -l 2>/dev/null | grep -v "delete_old_users.sh"; echo "0 0 * * * /bin/bash $DELETE_SCRIPT >> /home/${{ secrets.RPI_USER }}/MOUP-Server/delete_old_users.log 2>&1") | crontab -
            # echo "Crontab setup complete."
            # === 스크립트 종료 ===
          EOF